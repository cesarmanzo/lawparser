package lawparser

import (
	"fmt"
	"github.com/tugorez/textonumber"
	"strings"
	"unicode"
	"unicode/utf8"
)

type stateFn func(*lexer) stateFn

type Pos int

type lexer struct {
	input []byte
	state stateFn
	char  rune
	pos   Pos
	width Pos
	items chan item
	done  bool
}

//peek will inc the counter
func (self *lexer) peek() {
	if int(self.pos+self.width) >= len(self.input) {
		self.char = rune(0)
		return
	}
	var s int
	self.pos += self.width
	self.char, s = utf8.DecodeRune(self.input[self.pos:])
	self.width = Pos(s)

}

//reset will return the counter to a specific "pos" position
func (self *lexer) reset(pos Pos) {
	self.pos = pos
	self.width = Pos(0)
	self.peek()
}

//confirm will consume the bytes until "pos"
func (self *lexer) confirm() {
	if len(self.input) == 1 {
		self.input = nil
	}
	self.input = self.input[self.pos:]
	self.pos = Pos(0)
}

//run is in charge of find and run the diferent states of the lexer
func (self *lexer) run() {
	for self.state = lexInsideAction; self.state != nil; {
		self.state = self.state(self)
	}
	close(self.items)
}

//next item will return the next item generated by the lexer
func (self *lexer) nextItem() item {
	it := <-self.items
	return it
}

//emit will be called by states
func (self *lexer) emit(item item) {
	self.items <- item
}

//lex will initialize a lexer struct and run the necesary
//to start serving items
func lex(input []byte) *lexer {
	l := &lexer{
		input: input,
		pos:   Pos(0),
		width: Pos(0),
		items: make(chan item),
	}
	l.peek()
	go l.run()
	return l
}

/*Lexers*/
func lexInsideAction(l *lexer) stateFn {
	switch {
	case isEOF(l.char):
		return lexEOF
	case isSpace(l.char):
		return lexSpace
	case isDigit(l.char):
		return lexDigit
	case isSymbol(l.char):
		return lexSymbol
	case isLetter(l.char):
		return lexLetter
	case isNewLine(l.char):
		return lexNewLine
	default:
		return lexUndefined
	}
}
func lexUndefined(l *lexer) stateFn {
	_, _ = peekUndefined(l)
	l.confirm()
	//change this bitch
	//make a log
	return lexInsideAction
}
func lexSpace(l *lexer) stateFn {
	peekSpace(l)
	l.confirm()
	return lexInsideAction
}
func lexDigit(l *lexer) stateFn {
	val, _ := peekDigit(l)
	l.confirm()
	l.emit(item{itemNumber, val})
	return lexInsideAction
}
func lexSymbol(l *lexer) stateFn {
	val, _ := peekSymbol(l)
	l.confirm()
	l.emit(item{itemSymbol, val})
	return lexInsideAction
}

//reserved,
func lexLetter(l *lexer) stateFn {
	if val, is := peekReserved(l); is {
		l.emit(item{itemReserved, val})
	} else if val, is = peekRoman(l); is {
		l.emit(item{itemRoman, val})
	} else if val, is = peekOrdinal(l); is {
		l.emit(item{itemOrdinal, val})
	} else if val, is = peekLatin(l); is {
		l.emit(item{itemLatin, val})
	} else {
		val, is = peekWord(l)
		l.emit(item{itemWord, val})
	}
	l.confirm()
	return lexInsideAction
}

func lexNewLine(l *lexer) stateFn {
	peekNewLine(l)
	l.confirm()
	if typ, val, is := peekContainer(l); is {
		l.emit(item{typ, val})
		l.confirm()
		//muy importante, siempre tienes que escanear primero si es un numero (por los numeros romanos que tambien son letras)
	} else if val, is := peekSubArticleNum(l); is {
		l.emit(item{itemSubArticleNum, val})
		l.confirm()
	} else if val, is := peekSubArticleLet(l); is {
		l.emit(item{itemSubArticleLet, val})
		l.confirm()
	} else {
		l.emit(item{itemNewLine, ""})
	}
	return lexInsideAction
}

func lexEOF(l *lexer) stateFn {
	l.emit(item{itemEOF, ""})
	l.done = true
	return nil
}

/*Peekers*/
func peekSpace(l *lexer) (val string, is bool) {
	for ; isSpace(l.char); l.peek() {
	}
	is = true
	return
}

func peekDigit(l *lexer) (val string, is bool) {
	for ; isDigit(l.char); l.peek() {
		val += string(l.char)
	}
	if len(val) > 0 {
		is = true
	}
	return
}

func peekSymbol(l *lexer) (val string, is bool) {
	for ; isSymbol(l.char); l.peek() {
		val += string(l.char)
	}
	if len(val) > 0 {
		is = true
	}
	return
}

func peekWord(l *lexer) (val string, is bool) {
	for ; isLetter(l.char); l.peek() {
		val += string(l.char)
	}
	if len(val) > 0 {
		is = true
	}
	return
}

func peekNewLine(l *lexer) (val string, is bool) {
	if is = isNewLine(l.char); is {
		l.peek()
	}
	return
}

func peekRoman(l *lexer) (val string, is bool) {
	backup := l.pos
	val, is = peekWord(l)
	val, is = isRoman(val)
	if !is {
		l.reset(backup)
	}
	return
}

func peekLatin(l *lexer) (val string, is bool) {
	backup := l.pos
	val, is = peekWord(l)
	val, is = isLatin(val)
	if !is {
		l.reset(backup)
	}
	return
}

func peekOrdinal(l *lexer) (val string, is bool) {
	backup := l.pos
	val, is = peekWord(l)
	val, is = isOrdinal(val)
	if !is {
		l.reset(backup)
	}
	return
}

func peekReserved(l *lexer) (val string, is bool) {
	backup := l.pos
	val, is = peekWord(l)
	val, is = isReserved(val)
	if !is {
		l.reset(backup)
	}
	return
}
func peekAnyNumber(l *lexer) (val string, is bool) {
	backup := l.pos
	if val, is = peekDigit(l); is {
	} else if val, is = peekRoman(l); is {
	} else if val, is = peekOrdinal(l); is {
	} else if val, is = peekLatin(l); is {
	} else {
		l.reset(backup)
	}
	return
}

func peekAnyNumbers(l *lexer) (val string, is bool) {
	backup := l.pos
	for v, is := peekAnyNumber(l); is; v, is = peekAnyNumber(l) {
		val += v
		peekSpace(l)
	}
	if len(val) > 0 {
		is = true
	} else {
		l.reset(backup)
	}
	return
}

func peekContainer(l *lexer) (typ itemType, val string, is bool) {
	backup := l.pos
	//what kind of container is?
	tp, is := peekReserved(l)
	if !is {
		l.reset(backup)
		return
	}
	typ = containerType[tp]
	peekSpace(l)
	// what is the id of the container?
	val, is = peekAnyNumbers(l)
	if !is {
		l.reset(backup)
		return
	}
	// is it really a container ?
	if _, is := peekSymbol(l); is {

	} else if _, is = peekNewLine(l); is {

	} else {
		l.reset(backup)
	}
	return
}

func peekSubArticleLet(l *lexer) (val string, is bool) {
	backup := l.pos
	val, is = peekWord(l)
	if len(val) > 1 || !is {
		l.reset(backup)
		is = false
		return
	}
	_, is = peekSymbol(l)
	if !is {
		l.reset(backup)
	}
	return
}
func peekSubArticleNum(l *lexer) (val string, is bool) {
	backup := l.pos
	val, is = peekAnyNumbers(l)
	if !is {
		l.reset(backup)
		return
	}
	_, is = peekSymbol(l)
	if !is {
		l.reset(backup)
	}
	return
}
func peekUndefined(l *lexer) (val string, is bool) {
	for ; isUndefined(l.char); l.peek() {
		val += string(l.char)
	}
	if len(val) > 0 {
		is = true
	}
	return
}

/*Validators*/
func isSpace(char rune) bool {
	return !isNewLine(char) && unicode.IsSpace(char)
}

func isDigit(char rune) bool {
	return unicode.IsDigit(char)
}

func isNewLine(char rune) bool {
	return char == '\n'
}

func isSymbol(char rune) bool {
	return unicode.IsSymbol(char) || unicode.IsPunct(char)
}

func isLetter(char rune) bool {
	return unicode.IsLetter(char)
}
func isUndefined(char rune) bool {
	return !isSpace(char) && !isDigit(char) &&
		!isNewLine(char) && !isSymbol(char) &&
		!isLetter(char) && !isEOF(char)
}
func isEOF(char rune) bool {
	return char == rune(0)
}

func isReserved(word string) (val string, is bool) {
	word = strings.ToLower(word)
	val, is = Reserved[word]
	return
}

func isOrdinal(word string) (val string, is bool) {
	num, is := textonumber.IsOrdinal(word)
	val = fmt.Sprint(num)
	return
}

func isRoman(word string) (val string, is bool) {
	num, is := textonumber.IsRoman(word)
	val = fmt.Sprint(num)
	if num == 100 || num == 500 {
		is = false
	}
	return
}
func isLatin(word string) (val string, is bool) {
	word = strings.ToLower(word)
	if word == "bis" || word == "ter" {
		val = word
		is = true
	}
	return
}
